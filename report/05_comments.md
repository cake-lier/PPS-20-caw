# Commenti finali

Portare a termine il progetto non è stato un compito facile. È stato difficile sia ottenere un prodotto finale che fosse conforme agli standard prefissati, sia mantenere organizzato il processo di sviluppo. Anche un progetto relativamente contenuto come il nostro ha richiesto molte accortezze per poter essere portato a termine con successo, anche considerando di dover rispettare le *deadline* scelte. Non è facile individuare quali sono i compiti da svolgere, qual è la loro priorità e stimarne i tempi in giorni-persona e in giorni solari. A questo si aggiungono le complicazioni di due paradigmi di programmazione nuovi, quindi due nuovi modi di intendere il comportamento di un programma. Il tutto cercando di mantenere degli standard di qualità del codice interna ed esterna elevati.

Nonostante tutto questo, possiamo dire di avere raggiunto i nostri obiettivi. Con la collaborazione di tutti e l'aderenza quanto più possibile stretta ad un processo "agile", siamo riusciti a mantenere un'efficienza molto elevata durante tutto il progetto. È stato quindi molto più semplice rispettare le scadenze settimanali rispetto ad altri progetti già svolti. Inoltre, una progettazione iniziale accurata, ma non dettagliata fino all'estremo, è stata molto utile per guidarci durante la fase di sviluppo evitandoci di brancolare nel buio e commettere errori che avrebbero potuto costare diverse ore nella sistemazione. L'uso degli *unit test* in maniera sistematica attraverso l'approccio adottato di "Test-Driven Development", nonché l'uso di cicli di sviluppo molto brevi, hanno permesso di minimizzare la presenza di errori e velocizzare la produzione di codice di qualità. I *daily scrum* in cui fare *assessment* del lavoro svolto e in cui decidere come proseguire hanno permesso di evitare scostamenti dal piano di progetto troppo elevati. Anche le dimensioni del progetto e l'esperienza e la bravura dei membri del nostro *team* di sviluppo hanno giocato la loro parte, che non viene messa in dubbio in nessun modo, ma senza l'utilizzo delle tecniche già citate difficilmente saremmo riusciti ad ottenere i risultati che abbiamo poi avuto.

Ci siamo anche dovuti scontrare con le difficoltà nell'utilizzo di alcune librerie che hanno un'integrazione complicata con il linguaggio scala oppure con le *pipeline* di "Continuous Integration" offerte da GitHub, ovverosia "JavaFX" e "TestFX". Il linguaggio PROLOG ha presentato le sue peculiari difficoltà nella scrittura del codice: la sua forma estremamente idiomatica richiede lo sforzo di uscire dalla *forma mentis* della programmazione tradizionale, che non è uno sforzo indifferente. Abbiamo però avuto un'esperienza che giudichiamo positiva con il linguaggio scala. Esso infatti permette una transizione molto fluida dallo stile orientato agli oggetti a quello funzionale e viceversa, permettendo di sviluppare codice molto compatto in maniera molto efficiente, molto più di quanto non fosse possibile con Java. Le uniche difficoltà che abbiamo riscontrato sono legate all'IDE che non è ancora pronto per la versione 3 del linguaggio, perciò presenta tutta una serie di funzionalità limitate che complicano il processo di sviluppo. Anche gli strumenti di *build automation* e *continuous integration* sono stati particolarmente agevoli nell'utilizzo e permettono una velocizzazione non indifferente del processo di sviluppo.

In sintesi, possiamo dirci soddisfatti del progetto che abbiamo svolto. È sempre possibile aggiungere nuove funzionalità ed apportare ulteriori migliorie al codice. Si potrebbero aggiungere ancora più tipi di cellule con comportamenti sempre più complessi, aggiungere più livelli, permettere ai giocatori di condividere i livelli via Internet, avere più aree di gioco, eccetera. Tutto questo però esula dal gioco originale e dalla sua "*mod*", su cui ci siamo basati per sviluppare il nostro progetto, e perciò riteniamo corretto affermare che quest'ultimo può dirsi a ragione concluso.
